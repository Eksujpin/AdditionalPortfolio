PLC 5.1: Following files were created:
merger.fsx
Merger.java


PLC 5.7: This part is intentionally left blank


PLC 6.1: Ran the code given
#1
run (fromString @"let add x = let f y = x + y in f end
                  in add 2 5 end");;
    --> Int 7
#2
run (fromString @"let add x = let f y = x+y in f end
                  in let addtwo = add 2 in addtwo 5 end end");;
    --> Int 7
#3
run (fromString @"let add x = let f y = x+y in f end
                  in let addtwo = add 2
                      in let x = 77 in addtwo 5 end
                  end end");;
    --> Int 7

#3 Explanation: when reading the code we see that it behaves as one might expect, as the x value is already defined in the addTwo closure as 2, 
	therefore it is to be expected that the 77 does not overwrite and hence the result is 

#4
run (fromString "let add x = let f y = x + y in f end in add 2 end");;
    --> Closure
    ("f", "y", Prim ("+", Var "x", Var "y"),
     [("x", Int 2);
      ("add",
       Closure
         ("add", "x", Letfun ("f", "y", Prim ("+", Var "x", Var "y"), Var "f"),
          []))])

#4 Explanation: this will evaluate to f y = 2+y
	This is because the outer let body, containing the add 2, calls the add function with 2 as parameters, 
	hence it returns the function f y = x+y where x = 2

***** alt efter denne linje er ikke testet *****

PLC 6.2: Look in Absyn.fs and HigherFun.fs for our solutions, again looking for *Exercise 6.2*

PLC 6.3: Look in FunLex.fsl and FunPar.fsy for our solutions, again looking for *Exercise 6.3*

PLC 6.4: piuctures
exercise_6_4_part1.png
exercise_6_4_part2.png