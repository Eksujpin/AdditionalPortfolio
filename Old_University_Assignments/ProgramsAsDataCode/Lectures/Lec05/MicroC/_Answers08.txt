PLC 8.1
compiling gives:
val it : Machine.instr list =
  [LDARGS; CALL (1, "L1"); STOP; Label "L1"; INCSP 1; INCSP 1; INCSP 100;
   GETSP; CSTI 99; SUB; INCSP 100; GETSP; CSTI 99; SUB; INCSP 100; GETSP;
   CSTI 99; SUB; INCSP 100; GETSP; CSTI 99; SUB; GETBP; CSTI 2; ADD; CSTI 1;
   STI; INCSP -1; GOTO "L3"; Label "L2"; GETBP; CSTI 103; ADD; LDI; GETBP;
   CSTI 2; ADD; LDI; ADD; CSTI 0; STI; INCSP -1; GETBP; CSTI 2; ADD; GETBP;
   CSTI 2; ADD; LDI; CSTI 1; ADD; STI; INCSP -1; INCSP 0; Label "L3"; GETBP;
   CSTI 2; ADD; LDI; GETBP; CSTI 0; ADD; LDI; SWAP; LT; NOT; IFNZRO "L2";
   GETBP; CSTI 2; ADD; CSTI 1; STI; INCSP -1; GOTO "L5"; Label "L4"; GETBP;
   CSTI 204; ADD; LDI; GETBP; CSTI 2; ADD; LDI; ADD; GETBP; CSTI 305; ADD; LDI;
   GETBP; CSTI 2; ADD; LDI; ADD; CSTI 0; STI; STI; INCSP -1; GETBP; CSTI 2;
   ADD; ...]

running in java gives
java Machine ex11.out 8
1 5 8 6 3 7 2 4
1 6 8 3 7 4 2 5
1 7 4 6 8 2 5 3
1 7 5 8 2 4 6 3
2 4 6 8 3 1 7 5
2 5 7 1 3 8 6 4
2 5 7 4 1 8 6 3
...............


PLC 8.3
Changed comp.fs
Created ex8.3.c for testing

PLC 8.4
For 8.3, the problem is that the "bytecode" saves i on the stack, and whenever i is accessed, it is pulled from the stack, modified, and saved on the stack. E.g. in the statement i = i - 1, i is loaded from the stack, subtracted one and then saved to the stack. The handwritten version just makes sure "i" is on the top of the stack whenever it is needed.

In 8.13, there is a Label and a Jump for every part of the if-statements, and they seem excessive. Also, != was translated to a double negative, as != was translated to [EQ; NOT; IFNZRO <label>]. It might be smarter to translated to [EQ; IFZERO <label>], but that might be complicated.


PLC 8.5 
Changed files: at comments "exercise 8.5"
Absyn.fs 
Clex.fsl
CPar.fsy
Comp.fs
Created file "ex8.5.c" to test

8.6
Changed files: at comments "exercise 8.6"
Absyn.fs 
Clex.fsl
CPar.fsy
Comp.fs